name: Minecraft Docker Image CI

on:
  workflow_dispatch:
    inputs:
      PROJECT_ID:
        description: 'CurseForge项目ID'
        required: true
        type: string
      SERVER_VERSION:
        description: 'Minecraft服务端版本'
        required: true
        type: string
      MOD_LOADERS:
        description: 'Minecraft模组加载器 (fabric/forge)'
        required: true
        default: 'fabric'
        type: string
      JDK_VERSION:
        description: 'Java版本'
        required: true
        default: '21'
        type: string

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      REGISTRY: ghcr.io
      JAR_CATALOG: ${{ github.workspace }}/public
      CURSEFORGE_API: https://www.curseforge.com/api/v1
      FABRIC_META: https://meta.fabricmc.net/v2/versions
      TEMP_CACHE_CATALOG: ${{ github.workspace }}/temp/cache/
      CURSEFORGE_DOWNLOAD_API: https://mediafilez.forgecdn.net/files
      FORGE_DOWNLOAD: https://maven.minecraftforge.net/net/minecraftforge/forge
      FABRIC_API_BASE_URL: https://api.github.com/repos/FabricMC/fabric/releases?per_page=100
      PROMOTION_FILE: https://files.minecraftforge.net/net/minecraftforge/forge/promotions_slim.json

    steps:
      - uses: actions/checkout@v4
      - name: Set Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Set QEMU
        uses: docker/setup-qemu-action@v3

      # 验证模组整合包是否存在
      - name: Validate Modpack
        run: |
          RESPONSE=$(curl -s "${{ env.CURSEFORGE_API }}/mods/${{ inputs.PROJECT_ID }}/files")
          if [ $(echo "$RESPONSE" | jq -r '.data.id') == null ]; then
            echo "::error::Invalid Project ID"
            exit 1
          fi

      # 登录到容器仓库
      - name: Log in to the Container registry
        uses: docker/login-action@v3
        id: docker-login
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # 初始化环境
      - name: Init Env
        run: |
          sudo mkdir -p ${{ env.JAR_CATALOG }}
          sudo mkdir -p ${{ env.TEMP_CACHE_CATALOG }}
          sudo apt-get -qq -y update
      - name: Set JDK
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: ${{ inputs.JDK_VERSION }}

      # 下载模组整合包并解析清单
      - name: Download and Parse Manifest
        id: manifest
        uses: actions/github-script@v7
        env:
          PROJECT_ID: ${{ inputs.PROJECT_ID }}
          MOD_LOADERS: ${{ inputs.MOD_LOADERS }}
          SERVER_VERSION: ${{ inputs.SERVER_VERSION }}
        with:
          script: |
            const { PROJECT_ID, MOD_LOADERS, SERVER_VERSION, CURSEFORGE_API, CURSEFORGE_DOWNLOAD_API } = process.env;
            // 封装分页请求
            const files = await (async () => {
              for (let page = 0; page < 10; page++) {
                const res = await fetch(`${process.env.CURSEFORGE_API}/mods/${PROJECT_ID}/files?pageIndex=${page}&pageSize=50&sort=dateCreated&sortDescending=true`);
                if (!res.ok) continue;
                const { data } = await res.json();
                const hit = data.find(f =>
                  f.gameVersions?.some(v => v.toLowerCase() === SERVER_VERSION.toLowerCase()) &&
                  f.gameVersions?.some(v => v.toLowerCase() === MOD_LOADERS.toLowerCase())
                );
                if (hit) return hit;
              }
              core.setFailed(`找不到匹配版本 ${SERVER_VERSION}/${MOD_LOADERS} 的 modpack 文件`);
            })();
            // 下载整合包
            const fileId = files.id.toString();
            await exec.exec('curl', ['-k', '-sS', '-o', 'modpack.zip', `${CURSEFORGE_DOWNLOAD_API}/${fileId.slice(0,4)}/${fileId.slice(4,7)}/${encodeURIComponent(files.fileName)}`]);
            // 取出 manifest.json
            await exec.exec('unzip', ['-j', 'modpack.zip', 'manifest.json']);
            // 解析字段
            const manifest = JSON.parse(require('fs').readFileSync('manifest.json', 'utf8'));
            const loaderVer = (manifest.minecraft.modLoaders[0]?.id || '').split('-')[1];
            const modList = manifest.files?.map(f => `${f.projectID}:${f.fileID}`).join(',') || '';
            const normalized = manifest.name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9_-]/g, '');
            // 输出到 GITHUB_ENV
            require('fs').appendFileSync(
              process.env.GITHUB_ENV, 
              [
                `NORMALIZED_NAME=${normalized}`,
                `MODPACK_VERSION=${manifest.version}`,
                `MINECRAFT_VERSION=${manifest.minecraft.version}`,
                `MOD_LIST=${modList}`,
                `MOD_LOADER_VERSION=${loaderVer}`
              ].join('\n')
            );
            core.info(`成功下载版本 ${SERVER_VERSION} 的 modpack：${files.fileName}`);

      - name: Download Mod Loader & Fabric API
        run: |
          case "${{ inputs.MOD_LOADERS }}" in
            fabric)
              LOADER=$(curl -s $FABRIC_META/loader | jq -r '.[0].version')
              INSTALLER=$(curl -s $FABRIC_META/installer | jq -r '.[0].version')
              curl -sSL "$FABRIC_META/loader/$MINECRAFT_VERSION/$LOADER/$INSTALLER/server/jar" -o server-core.jar
              java -jar server-core.jar --nogui --universe $TEMP_CACHE_CATALOG
              ;;
            forge)
              FORGE_VERSION=$(curl -s $PROMOTION_FILE | jq -r --arg v "$MINECRAFT_VERSION" '.promos[$v + "-latest"]')
              curl -sSL "$FORGE_DOWNLOAD/$MINECRAFT_VERSION-$FORGE_VERSION/forge-$MINECRAFT_VERSION-$FORGE_VERSION-installer.jar" -o forge-installer.jar
              java -jar forge-installer.jar --installServer
              mv forge-$MINECRAFT_VERSION-$FORGE_VERSION-universal.jar server-core.jar && rm -rf forge-installer.jar *.txt *.log run.*
              java -jar server-core.jar --nogui --universe $TEMP_CACHE_CATALOG
              ;;
          esac

      # 并发下载所有模组文件
      - name: Download Mods in Parallel
        run: |
          # 生成下载清单
          echo "${MOD_LIST}" | tr ',' '\n' | while IFS=":" read -r PID FID; do
            JSON=$(curl -s "${{ env.CURSEFORGE_API }}/mods/${PID}/files/${FID}")
            FILE_ID=$(echo "$JSON" | jq -r '.data.id')
            FILE_NAME=$(echo "$JSON" | jq -r '.data.fileName')
            # 文件名 URL-encode
            SAFE_FILE_NAME=$(jq -nr --arg fn "$FILE_NAME" '$fn|@uri')
            # 下载地址
            DOWNLOAD_URL="${{ env.CURSEFORGE_DOWNLOAD_API }}/$((10#${FILE_ID:0:4}))/$((10#${FILE_ID:4:3}))/$SAFE_FILE_NAME"
            # 文件名
            CLEAN_FILE_NAME=$(echo "$FILE_NAME" | tr -d "'\"")
            printf '%s\t%s\n' "$DOWNLOAD_URL" "$CLEAN_FILE_NAME"
          done > download-list.txt
          # 并发下载
          sudo bash -c "
            parallel --will-cite -j\$(nproc) --colsep '\t' '
            URL={1}
            CLEAN_NAME={2}
            echo \"[下载链接] \$URL\"
            OUTPUT_PATH=\"${JAR_CATALOG}/\$CLEAN_NAME\"
            if curl -k -sS -fL -o \"\$OUTPUT_PATH\" \
                  -H \"User-Agent: Mozilla/5.0\" \
                  -H \"Referer: https://curseforge.com/\" \
                  --globoff \
                  \"\$URL\"
            then
              echo \"[成功] \$CLEAN_NAME 已下载\"
            else
              STATUS=\$?
              echo \"[失败] \$CLEAN_NAME 下载失败 (退出码: \$STATUS)\" >&2
              exit 1
            fi
            ' :::: download-list.txt
          "

      # 构建并推送多架构镜像
      - name: Build and Push Docker Image
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          platforms: linux/amd64,linux/arm64
          tags: ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.NORMALIZED_NAME }}:${{ env.MODPACK_VERSION }}