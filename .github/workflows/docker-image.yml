name: Minecraft Docker Image CI

on:
  workflow_dispatch:
    inputs:
      PROJECT_ID:
        description: 'CurseForge项目ID'
        required: true
        type: string
      SERVER_VERSION:
        description: 'Minecraft服务端版本'
        required: true
        type: string
      MOD_LOADERS:
        description: 'Minecraft模组加载器 (fabric/forge)'
        required: true
        default: 'fabric'
        type: string

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      REGISTRY: ghcr.io
      JAR_CATALOG: public
      CURSEFORGE_API: https://www.curseforge.com/api/v1
      CURSEFORGE_DOWNLOAD_API: https://mediafilez.forgecdn.net/files

    steps:
      - uses: actions/checkout@v4

      # 设置多架构构建环境
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      # 验证Modpack是否存在
      - name: Validate Modpack
        run: |
          RESPONSE=$(curl -s "${{ env.CURSEFORGE_API }}/mods/${{ inputs.PROJECT_ID }}/files")
          if [ $(echo "$RESPONSE" | jq -r '.data.id') == null ]; then
            echo "::error::Invalid Project ID"
            exit 1
          fi

      - name: Init Env
        run: |
          mkdir -p ${{ env.JAR_CATALOG }}
          sudo apt-get -qq -y update

      - name: Download and Parse Manifest
        id: manifest
        run: |
          # 翻页参数
          PAGE_INDEX=0
          MAX_PAGES=10
          FOUND_FILE=""
          PROJECT_ID="${{ inputs.PROJECT_ID }}"
          MOD_LOADERS="${{ inputs.MOD_LOADERS }}"
          CURSEFORGE_API="${{ env.CURSEFORGE_API }}"
          SERVER_VERSION="${{ inputs.SERVER_VERSION }}"
          # 验证环境变量
          echo "使用参数:"
          echo "PROJECT_ID=${PROJECT_ID}"
          echo "MOD_LOADERS=${MOD_LOADERS}"
          echo "SERVER_VERSION=${SERVER_VERSION}"
          echo "CURSEFORGE_API=${CURSEFORGE_API}"
          # 翻页查找匹配版本的文件
          while [[ $PAGE_INDEX -lt $MAX_PAGES ]]; do
            echo "正在查找第 $((PAGE_INDEX+1)) 页..."
            API_URL="${CURSEFORGE_API}/mods/${PROJECT_ID}/files?pageInde=$PAGE_INDEX&pageSize=50&sort=dateCreated&sortDescending=true"
            echo "请求URL: ${API_URL}"
            FILES_JSON=$(curl -v -s -w "\nHTTP_STATUS:%{http_code}" "${API_URL}")
            HTTP_STATUS=$(echo "$FILES_JSON" | grep 'HTTP_STATUS:' | sed 's/HTTP_STATUS://')
            FILES_JSON=$(echo "$FILES_JSON" | sed '/HTTP_STATUS:/d')
            echo "HTTP响应状态: ${HTTP_STATUS}"
            # 检查API响应是否有效
            if [[ "$HTTP_STATUS" != "200" ]]; then
              echo "::warning::API 返回错误状态 ${HTTP_STATUS}"
              ((PAGE_INDEX++))
              continue
            fi
            # 检查API响应是否为有效JSON
            if ! jq -e . >/dev/null 2>&1 <<<"$FILES_JSON"; then
              echo "::warning::API 返回无效 JSON"
              ((PAGE_INDEX++))
              continue
            fi
            # 内容过滤
            FOUND_FILE=$(echo "$FILES_JSON" | jq -r \
            --arg ver "$SERVER_VERSION" \
            --arg loader "$MOD_LOADERS" '
            .data? // [] |
            map(select(
            .gameVersions != null and
            (
            ([.gameVersions] | flatten | map(select(. != null) | ascii_downcase) | any(. == ($ver | ascii_downcase)))
            and
            ([.gameVersions] | flatten | map(select(. != null) | ascii_downcase) | any(. == ($loader | ascii_downcase)))
            )
            )) |
            if length > 0 then .[0] | {id, fileName} else null end
            ')
            # 调试输出
            echo "过滤结果: ${FOUND_FILE}"
            # 找到匹配则跳出循环
            if [[ "$(echo "$FOUND_FILE" | jq -r '.id')" != "null" ]] && [[ -n "$FOUND_FILE" ]]; then
              echo "找到匹配文件！"
              break
            fi
            ((PAGE_INDEX++))
          done
          # 检查是否找到匹配文件
          if [[ -z "$FOUND_FILE" ]] || [[ "$(echo "$FOUND_FILE" | jq -r '.id')" == "null" ]]; then
            echo "::error::找不到匹配版本 $SERVER_VERSION/$MOD_LOADERS 的modpack文件"
            exit 1
          fi
          # 提取文件信息
          FILE_ID=$(echo "$FOUND_FILE" | jq -r '.id')
          FILE_NAME=$(echo "$FOUND_FILE" | jq -r '.fileName')
          FILE_NAME_ENCODE=$(echo "$FILE_NAME" | tr -d '\n' | jq -sRr '@uri')
          echo "找到匹配文件: ID=$FILE_ID, 文件名=$FILE_NAME"
          # 修复下载URL格式
          DOWNLOAD_URL="https://mediafilez.forgecdn.net/files/${FILE_ID:0:4}/${FILE_ID:4:3}/$FILE_NAME_ENCODE"
          echo "下载URL: $DOWNLOAD_URL"
          # 下载modpack
          curl -fL -o modpack.zip "$DOWNLOAD_URL" || {
            echo "::error::下载modpack文件失败"
            exit 1
          }
          # 解压并解析manifest
          unzip -j modpack.zip manifest.json -d . || {
            echo "解压失败，压缩包内容:"
            unzip -l modpack.zip || true
            echo "::error::解压manifest.json失败"
            exit 1
          }
          MANIFEST_JSON=$(jq -c . manifest.json)
          echo "MANIFEST_JSON=$MANIFEST_JSON" >> $GITHUB_ENV
          echo "MINECRAFT_VERSION=$(jq -r '.minecraft.version' <<< "$MANIFEST_JSON")" >> $GITHUB_ENV
          echo "FILE_IDS=$(jq -r '[.files[] | "\(.projectId):\(.fileId)"] | join(",")' <<< "$MANIFEST_JSON")" >> $GITHUB_ENV
          echo "MOD_LOADER_VERSION=$(jq -r '.minecraft.modLoaders[0].id' <<< "$MANIFEST_JSON" | cut -d- -f2)" >> $GITHUB_ENV
          echo "成功下载版本 $SERVER_VERSION 的modpack文件：$FILE_NAME"

      # 规范化镜像名称
      - name: Normalize Image Name
        run: |
          MODPACK_NAME=$(echo "$MANIFEST_JSON" | jq -r '.name')
          # 转换规则：小写化、空格转横线、移除特殊字符 
          NORMALIZED_NAME=$(echo "$MODPACK_NAME" | 
            tr '[:upper:]' '[:lower:]' |
            tr ' ' '-' |
            sed 's/[^a-z0-9_-]//g')
          MODPACK_VERSION=$(echo "$MANIFEST_JSON" | jq -r '.version')
          echo "NORMALIZED_NAME=$NORMALIZED_NAME" >> $GITHUB_ENV
          echo "MODPACK_VERSION=$MODPACK_VERSION" >> $GITHUB_ENV

      # 安装模组加载器
      - name: Install Mod Loader
        run: |
          mkdir -p /temp/cache/
          case "${{ inputs.MOD_LOADERS }}" in
            fabric)
              # 安装Fabric核心 
              FABRIC_META="https://meta.fabricmc.net/v2/versions"
              LOADER_VER=$(curl -s $FABRIC_META/loader | jq -r '.[0].version')
              INSTALLER_VER=$(curl -s $FABRIC_META/installer | jq -r '.[0].version')
              curl -fSL -o server-core.jar \
                "https://meta.fabricmc.net/v2/versions/loader/${{ env.MINECRAFT_VERSION }}/$LOADER_VER/$INSTALLER_VER/server/jar"
              # 获取Fabric API
              FABRIC_API_URL=$(curl -s "https://api.github.com/repos/FabricMC/fabric/releases" | 
                jq -r --arg ver "${{ env.MINECRAFT_VERSION }}" '.[] | select(.tag_name | contains($ver)) | .assets[0].browser_download_url')
              curl -fSL -o ${{ env.JAR_CATALOG }}/fabric-api.jar "$FABRIC_API_URL"
              # 初始化服务端
              java -jar server-core.jar --nogui --universe /temp/cache/
              ;;
            forge)
              # 安装Forge核心 
              PROMOTION_FILE="https://files.minecraftforge.net/net/minecraftforge/forge/promotions_slim.json"
              FORGE_VERSION=$(curl -s $PROMOTION_FILE | jq -r --arg VER "${{ env.MINECRAFT_VERSION }}" '.promos[$VER + "-latest"]')
              if [ "$FORGE_VERSION" = "null" ]; then
                echo "::error::No Forge version available for ${{ env.MINECRAFT_VERSION }}"
                exit 1
              fi
              # 下载安装器
              curl -fSL -o forge-installer.jar \
                "https://maven.minecraftforge.net/net/minecraftforge/forge/${{ env.MINECRAFT_VERSION }}-$FORGE_VERSION/forge-${{ env.MINECRAFT_VERSION }}-$FORGE_VERSION-installer.jar"
              # 初始化服务端
              java -jar forge-installer.jar --installServer
              mv forge-${{ env.MINECRAFT_VERSION }}-$FORGE_VERSION-universal.jar server-core.jar
              rm -rf server.properties eula.txt README.txt user_jvm_args.txt forge-installer.jar *.log run.bat run.sh
              java -jar server-core.jar --nogui --universe /temp/cache/
              ;;
            *)
              echo "::error::Unsupported loader: ${{ inputs.MOD_LOADERS }}"
              exit 1
              ;;
          esac

      # 并发下载所有模组文件（动态并行度）
      - name: Download Mods in Parallel
        run: |
          mkdir -p mods
          # 准备下载列表 
          echo "${{ env.FILE_IDS }}" | tr ' ' '\n' | while IFS=":" read -r PID FID; do
            MOD_URL=$(curl -s "${{ env.CURSEFORGE_API }}/mods/$PID/files/$FID" | 
              jq -r '.data.downloadUrl')
            echo "$MOD_URL mods/$(basename "$MOD_URL")"
          done > download-list.txt
          cat download-list.txt | parallel --bar -j$(nproc) curl -L -o ${{ env.JAR_CATALOG }}/{2} {1}

      # 整理服务端文件
      - name: Prepare Server Files
        run: |
          # 清理旧文件并解压新内容
          rm -rf server-files
          unzip -o modpack.zip -d server-files
          # 优先级：server-overrides > overrides 
          if [ -d "server-files/server-overrides" ]; then
            cp -rf server-files/server-overrides/* .
          elif [ -d "server-files/overrides" ]; then
            cp -rf server-files/overrides/* .
          fi

      # 构建并推送多架构镜像
      - name: Build and Push Docker Image
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          platforms: linux/amd64,linux/arm64
          tags: ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.NORMALIZED_NAME }}:${{ env.MODPACK_VERSION }}